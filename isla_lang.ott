% Ott grammar for the symbolic output of isla-footprint, based on the Rust isla-lib/srf/smt.rs types

% SMT symbolic variables
metavar vvar ::=    {{ ocaml int }}
                    {{ phantom }}
                    {{ lex numeric }}
                    {{ ocamllex 'v'['0'-'9']+ }}
                    {{ ocamllex-of-string (function s -> int_of_string (String.sub s 1 (String.length s -1))) }}
                    {{ pp-raw x = string (string_of_int x) }}
                    {{ pp x = string ("v"^string_of_int x) }}



% register and field names, lexed with surrounding | | but represented without
% (do we want to represent these as strings, or as indices into a symbol table?  the former is simpler for now)
metavar name ::=    {{ ocaml string }}
                    {{ lex alphanum }}
                    {{ ocamllex '|'[^'|''\\']+'|' }}
                    {{ ocamllex-of-string (function s -> String.sub s 1 (String.length s -2)) }}

% bounded varaible (by let)
metavar bvar::=     {{ ocaml string }}
                    {{ lex alphanum }}
                    {{ ocamllex ['a'-'z''A'-'Z']+'!'['0'-'9']+ }}


% enum names of the form en_m
metavar enum ::=    {{ ocaml int * int }}
                    {{ lex alphanum }}
                    {{ ocamllex 'e'['0'-'9']+'_'['0'-'9']+ }}
                    {{ ocamllex-of-string (function s -> Scanf.sscanf s "e%[0-9]_%[0-9]" (fun a b -> (int_of_string a, int_of_string b))) }}
                    {{ pp-raw x = let (a,b) = x in !^(Printf.sprintf "%d/%d" b a) }}
                    {{ pp x = let (a,b) = x in !^(Printf.sprintf "e%d_%d" a b) }}

% enum type names of the form Enumn
metavar enum_ty ::= {{ ocaml int  }}
                    {{ lex alphanum }}
                    {{ ocamllex 'E''n''u''m'['0'-'9']+ }}
                    {{ ocamllex-of-string (function s -> Scanf.sscanf s "Enum%d" Fun.id) }}
                    {{ pp-raw x = !^(Printf.sprintf "Enum(%d)" x) }}
                    {{ pp x = !^(Printf.sprintf "Enum%d" x) }}





% various kinds of number (TODO) should be represented with the OCaml representation of bitvectors used by the Lem ocaml library
metavar u32 ::=     {{ ocaml int }}
                    {{ phantom }}
                    {{ lex numeric }}
                    {{ ocamllex ['0'-'9']+ }}
                    {{ ocamllex-of-string int_of_string }}
                    {{ pp x = string (string_of_int x) }}
                    {{ pp-raw x = string (string_of_int x) }}

%metavar u64 ::= {{ ocaml int}} {{ lex numeric }} {{ ocamllex ['0'-'9']* }} {{ ocamllex-of-string int_of_string }} {{ pp x = string (string_of_int x) }} {{ pp-raw x = string (string_of_int x) }}

metavar bvi ::=     {{ ocaml int }}
                    {{ lex numeric }}
                    {{ ocamllex ('b''v''-'?['0'-'9']+) }}
                    {{ ocamllex-of-string (function s -> int_of_string (String.sub s 2 (String.length s -2))) }}
                    {{ pp-raw x = string (string_of_int x) }}
                    {{ pp x = string ("bv"^string_of_int x) }}

metavar bv ::=      {{ ocaml string }}
                    {{ lex numeric }}
                    {{ ocamllex ('#''b'['0'-'1']+)|('#''x'['0'-'9''a'-'f''A'-'F']+) }}
                    {{ pp x = string (x) }}
                    {{ pp-raw x = string (x) }}

metavar str ::=     {{ ocaml string }}
                    {{ phantom }}
                    {{ lex alphanum }}
                    {{ ocamllex '\"'[^'\"']*'\"' }}
                    {{ pp x = string (x) }}
                    {{ pp-raw x = string (x) }}

indexvar j,k ::=    {{ ocaml int }}
                    {{ phantom }}

%%%%%%%%%%%%% parser source location machinery %%%%%%%%%%%%%%%%%%%
embed
{{ ocaml

type lrng =
  | UnknownRng
 (* | Int of string * lrng option *)
  | Generated of lrng
  | Range of Lexing.position * Lexing.position

(* TODO figure out how to use that *)
exception Parse_error_locn of lrng * string

let pp_lpos p =
  PPrint.string
    Lexing.(
      Printf.sprintf "File \"%s\", line %d, character %d" p.pos_fname p.pos_lnum
        (p.pos_cnum - p.pos_bol))

let rec pp_lrng l =
  match l with
  | UnknownRng -> PPrint.string "Unknown position"
  | Generated l -> PPrint.prefix 2 1 (PPrint.string "Generated:") (pp_lrng l)
  | Range (p1, p2) ->
      Lexing.(
        assert (p1.pos_fname = p2.pos_fname);
        if p1.pos_lnum = p2.pos_lnum then begin
          assert (p1.pos_bol == p2.pos_bol);
          PPrint.string
          @@ Printf.sprintf "File \"%s\", line %d, character %d-%d" p1.pos_fname p1.pos_lnum
               (p1.pos_cnum - p1.pos_bol) (p2.pos_cnum - p2.pos_bol)
        end
        else
          PPrint.string
          @@ Printf.sprintf "File \"%s\", line %d-%d" p1.pos_fname p1.pos_lnum p2.pos_lnum)
   (* | Int(s,lo) -> Printf.sprintf "Int: %s %s" s (match lo with Some l -> pp_lrng l | None -> "none") *)

}}

grammar
% TODO handle pretty printing of annotations
annot :: '' ::=                         {{ phantom }}
                                        {{ ocaml 'a }}
                                        {{ com Annotation }}
                                        {{ pp l = PPrint.empty }}
                                        {{ pp-raw l = PPrint.empty }}


svar :: '' ::=                          {{ ocaml 'v }}
                                        {{ phantom }}
                                        {{ pp-params ppv }}
                                        {{ pp ppv s = bar ^^ ppv s ^^ bar }}
                                        {{ pp-raw ppv s = ppv s }}
  | name                                :: :: SVarName {{ocaml name }}

var :: '' ::=                           {{ auxparam 'v }}
                                        {{ pp-params ppv }}
  | vvar                                :: :: Free
  | svar                                :: :: State
  | bvar                                :: :: Bound %variable bound by a let



%%%%%%%%%%%%%% from ast.rs %%%%%%%%%%%%%%%%%%%

% this is a type of sail values

% the "valu" is because ott menhir backend doesn't support ntr ocaml
% homs, so we have to work around the fact that val is OCaml-reserved
% in a more ugly way

grammar
valu :: 'Val_' ::=
 | vvar                                                 :: :: Symbolic
 | bool                                                 :: :: Bool   % TODO: fix syntax
 | (_ bvi u32 )                                         :: :: I  % I64 and I128
 | bv                                                   :: :: Bits
 | enum                                                 :: :: Enum
 | str                                                  :: :: String
 | (_ unit )                                            :: :: Unit
 | ( name (_ unit))                                     :: :: NamedUnit
 | (_ vec valu1  ..  valuk  )                           :: :: Vector  % TODO: fix syntax
 | (_ list valu1 .. valuk )                             :: :: List  % TODO: fix syntax
 | (_ struct  struct_element1 .. struct_elementk )      :: :: Struct
 | (_ poison )                                          :: :: Poison

struct_element :: '' ::=                                {{ phantom }}
                                                        {{ ocaml name * valu }}
                                                        {{ pp se = let (n,v) = se in pp_name n ^^ !^"," ^^ pp_valu v }}
                                                        {{ pp-raw se = let (n,v) = se in pp_raw_name n ^^ !^"," ^^ pp_raw_valu v }}
 | ( name valu )                                        :: :: Struct_elem {{ ocaml (name,valu) }}



%%%%%%%%%%%%%% from smt.rs %%%%%%%%%%%%%%%%%%%

%%% smt %%%

ty :: 'Ty_' ::=
  | Bool                                :: :: Bool
  | (_ BitVec u32 )                     :: :: BitVec
  | enum_ty                             :: :: Enum

bool :: '' ::=                          {{ ocaml bool }}
                                        {{ phantom }}
                                        {{ pp b = if b then string "true" else string "false" }}
                                        {{ pp-raw b = if b then string "true" else string "false" }}
  | true                                :: :: True {{ ocaml true }}
  | false                               :: :: False {{ ocaml false }}

% Operations that must be applied to exactly one element
unop :: '' ::=
  | not                                 :: :: Not
  | bvnot                               :: :: Bvnot
  | bvredand                            :: :: Bvredand
  | bvredor                             :: :: Bvredor
  | bvneg                               :: :: Bvneg
  | (_ extract u32 u32' )               :: :: Extract
  | (_ zero_extend u32 )                :: :: ZeroExtend
  | (_ sign_extend u32 )                :: :: SignExtend

% Arithmetic operations that must be applied to exactly two elements of the same size
bvarith :: '' ::=
  | bvnand                              :: :: Bvnand
  | bvnor                               :: :: Bvnor
  | bvxnor                              :: :: Bvxnor
  | bvsub                               :: :: Bvsub
  | bvudiv                              :: :: Bvudiv
  | bvudiv_i                            :: :: Bvudivi
  | bvsdiv                              :: :: Bvsdiv
  | bvsdiv_i                            :: :: Bvsdivi
  | bvurem                              :: :: Bvurem
  | bvsrem                              :: :: Bvsrem
  | bvsmod                              :: :: Bvsmod
  | bvshl                               :: :: Bvshl
  | bvlshr                              :: :: Bvlshr
  | bvashr                              :: :: Bvashr


% Comparison operations, they must be applied to exactly two elements of the same size
bvcomp :: '' ::=
  | bvult                               :: :: Bvult
  | bvslt                               :: :: Bvslt
  | bvule                               :: :: Bvule
  | bvsle                               :: :: Bvsle
  | bvuge                               :: :: Bvuge
  | bvsge                               :: :: Bvsge
  | bvugt                               :: :: Bvugt
  | bvsgt                               :: :: Bvsgt

% Operations that must be applied to exactly two elements
binop :: '' ::=
  | =                                   :: :: Eq
  | neq                                 :: :: Neq
  | bvarith                             :: :: Bvarith
  | bvcomp                              :: :: Bvcomp

% Arithmetic operations that can be applied to 2 or more elements of the same size
bvmanyarith :: '' ::=
  | bvand                               :: :: Bvand
  | bvor                                :: :: Bvor
  | bvxor                               :: :: Bvxor
  | bvadd                               :: :: Bvadd
  | bvmul                               :: :: Bvmul

% Operations that can be applied to 2 or more elements
manyop :: '' ::=
  | and                                 :: :: And
  | or                                  :: :: Or
  | bvmanyarith                         :: :: Bvmanyarith
  | concat                              :: :: Concat

exp :: '' ::=                           {{ aux _ annot }}
                                        {{ auxparam ('v, 'a) }}
                                        {{ pp-params ppv }}
                                        {{ menhir-start }}
                                        {{ menhir-start-type (string, Isla_lang_ast.lrng) Isla_lang_ast.exp }}
  | var                                 :: :: Var
  | bv                                  :: :: Bits
  | bool                                :: :: Bool
  | enum                                :: :: Enum
  | ( unop exp )                        :: :: Unop
  | ( binop exp1 exp2 )                 :: :: Binop
  | ( manyop exp1 .. expj )             :: :: Manyop
  | ( ite exp1 exp2 exp3 )              :: :: Ite
  | ( let ( ( bvar exp1 ) ) exp2 )      :: :: Let

smt :: '' ::= {{auxparam ('v, 'a) }} {{ pp-params ppv }}
  | ( declare-const var ty )            :: :: DeclareConst
  | ( define-const var exp )            :: :: DefineConst
  | ( assert exp )                      :: :: Assert

smt_ans :: '' ::=                       {{auxparam ('v, 'a) }}
                                        {{ pp-params ppv }}
                                        {{ menhir-start }}
                                        {{ menhir-start-type (string, Isla_lang_ast.lrng) Isla_lang_ast.smt_ans }}
  | ( error str )                       :: :: Error
  | ( :version str )                    :: :: Version
  | sat                                 :: :: Sat
  | unsat                               :: :: Unsat
  | unknown                             :: :: Unknown
  | unsupported                         :: :: Unsupported
  | exp                                 :: :: Exp



%%% events %%%

accessor :: '' ::=
  | (_ field name )                                                                             :: :: Field

accessor_list :: '' ::=
  | nil                                                                                         :: :: Nil
  | ( accessor1 .. accessork )                                                                  :: :: Cons

event :: '' ::=  {{ aux _ annot }} {{auxparam ('v, 'a) }} {{ pp-params ppv }}
  |  smt                                                                                        :: :: Smt
     % (define-enum n) is a sugar for (declare-datatypes () ((Enum_n en_0 en_1 ... en_(n-1) ))) but
     % it can appear multiple times and the type must be declared only once
  |  ( define-enum u32 )                                                                        :: :: DefineEnum
  |  ( branch u32 str )                                                                         :: :: Branch
  |  ( read-reg name accessor_list valu )                                                       :: :: ReadReg
  |  ( write-reg name accessor_list valu )                                                      :: :: WriteReg
  |  ( cycle )                                                                                  :: :: Cycle
   % ( read_mem result kind  addr   size)
  |  ( read-mem valu   valu' valu'' u32 )                                                       :: :: ReadMem
   % ( write_mem success kind  addr  data   size )
  |  ( write-mem vvar    valu  valu' valu'' u32' )                                              :: :: WriteMem

% not sure how ReadMem and WriteMem will be rendered

%%% top-level %%%

trc :: '' ::=                 {{ menhir-start }}
                              {{ auxparam ('v, 'a) }}
                              {{ menhir-start-type (string, Isla_lang_ast.lrng) Isla_lang_ast.trc }}
                              {{ pp-params ppv }}
 | ( trace event1 .. eventj )                                                                   :: :: Trace
