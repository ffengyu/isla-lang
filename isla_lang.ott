
% Ott grammar for the symbolic output of isla-footprint, based on the Rust isla-lib/srf/smt.rs types

% SMT symbolic variables
metavar var ::= {{ ocaml int }} {{ lex numeric }} {{ ocamllex 'v'['0'-'9']+ }} {{ ocamllex-of-string (function s -> int_of_string (String.sub s 1 (String.length s -1)))}}  {{ pp-raw x = string (string_of_int x) }} {{ pp x = string ("v"^string_of_int x) }}


% register and field names, lexed with surrounding | | but represented without
% (do we want to represent these as strings, or as indices into a symbol table?  the former is simpler for now)
metavar name ::= {{ ocaml string }} {{ lex alphanum }} {{ ocamllex '|'['0'-'9''a'-'z''A'-'Z''_']+'|' }} {{ ocamllex-of-string (function s -> String.sub s 1 (String.length s -2))}}



% various kinds of number, all of which (TODO) should be represented with the OCaml representation of bitvectors used by the Lem ocaml library
metavar u32 ::= {{ ocaml int}} {{ lex numeric }} {{ ocamllex ['0'-'9']+ }} {{ ocamllex-of-string int_of_string }} {{ pp x = string (string_of_int x) }} {{ pp-raw x = string (string_of_int x) }}

%metavar u64 ::= {{ ocaml int}} {{ lex numeric }} {{ ocamllex ['0'-'9']* }} {{ ocamllex-of-string int_of_string }} {{ pp x = string (string_of_int x) }} {{ pp-raw x = string (string_of_int x) }}

metavar bvi ::= {{ ocaml string}} {{ lex numeric }} {{ ocamllex ('b''v''-'?['0'-'9']+) }} {{ pp x = string (x) }} {{ pp-raw x = string (x) }}

metavar bv ::= {{ ocaml string}} {{ lex numeric }} {{ ocamllex ('#''b'['0'-'1']+)|('#''x'['0'-'9''a'-'f''A'-'F']+) }} {{ pp x = string (x) }} {{ pp-raw x = string (x) }}

metavar str ::= {{ ocaml string}} {{ lex alphanum }} {{ ocamllex '\"'[^'\"']*'\"' }} {{ pp x = string (x) }} {{ pp-raw x = string (x) }}





indexvar j,k ::= {{ ocaml int}}

%%%%%%%%%%%%% parser source location machinery %%%%%%%%%%%%%%%%%%%
embed
{{ ocaml
type l =
  | Unknown
  | Int of string * l option
  | Generated of l
  | Range of Lexing.position * Lexing.position

exception Parse_error_locn of l * string

let pp_lexing_position p = 
  Printf.sprintf  "file \"%s\" line %d char %d"
    p.Lexing.pos_fname p.Lexing.pos_lnum (p.Lexing.pos_cnum - p.Lexing.pos_bol)

let rec pp_l l =  match l with
    | Unknown -> "no location information available"
    | Generated l -> Printf.sprintf "Generated: %s"  (pp_l l)
    | Range(p1,p2) -> Printf.sprintf "Range: %s to %s" (pp_lexing_position p1) (pp_lexing_position p2)
    | Int(s,lo) -> Printf.sprintf "Int: %s %s" s (match lo with Some l -> pp_l l | None -> "none")

}}

grammar
l :: '' ::=                         {{ phantom }}
                                    {{ ocaml l }}
                                    {{ com Source location }}
                                    {{ pp l = pp_l l }} 
                                    {{ pp-raw l = pp_l l }}
  |                                 :: :: Unknown {{ ocaml Unknown }}




%%%%%%%%%%%%%% from ast.rs %%%%%%%%%%%%%%%%%%%

% this is a type of sail values

% the "valu" is because ott menhir backend doesn't support ntr ocaml
% homs, so we have to work around the fact that val is OCaml-reserved
% in a more ugly way

grammar
valu :: 'Val_' ::=             
 | var                                                  :: :: Symbolic
 | bool                                                 :: :: Bool   % TODO: fix syntax
 | (_ bvi u32 )                                         :: :: I  % I64 and I128
 | bv                                                   :: :: Bits
 | s                                                    :: :: String
 | (_ unit )                                            :: :: Unit
 | (_ vec valu1  ..  valuk  )         		        :: :: Vector  % TODO: fix syntax 
 | (_ list valu1 .. valuk )                             :: :: List  % TODO: fix syntax
 | (_ struct  struct_element1 .. struct_elementk )	:: :: Struct
 | (_ poison )                                          :: :: Poison

struct_element :: '' ::=
 | ( name valu )                                        :: :: Struct_elem


%%%%%%%%%%%%%% from smt.rs %%%%%%%%%%%%%%%%%%%

%%% smt %%%

ty :: 'Ty_' ::=
  | Bool                        :: :: Bool
  | (_ BitVec u32 )             :: :: BitVec

bool :: '' ::=   
  | true                        :: :: True
  | false                       :: :: False

unop :: '' ::=
  | not                         :: :: Not
  | bvnot                       :: :: Bvnot
  | bvredand                    :: :: Bvredand
  | bvredor                     :: :: Bvredor
  | bvneg                       :: :: Bvneg             
  | (_ extract u32 u32' )       :: :: Extract
  | (_ zero_extend u32 )        :: :: ZeroExtend
  | (_ sign_extend u32 )        :: :: SignExtend

binop :: '' ::=
  | neq                         :: :: Neq
  | and                         :: :: And
  | or                          :: :: Or
  | bvand                       :: :: Bvand
  | bvor                        :: :: Bvor
  | bvxor                       :: :: Bvxor
  | bvnand                      :: :: Bvnand
  | bvnor                       :: :: Bvnor
  | bvxnor                      :: :: Bvxnor
  | bvadd                       :: :: Bvadd                     
  | bvsub                       :: :: Bvsub                     
  | bvmul                       :: :: Bvmul                     
  | bvudiv                      :: :: Bvudiv            
  | bvsdiv                      :: :: Bvsdiv            
  | bvurem                      :: :: Bvurem            
  | bvsrem                      :: :: Bvsrem            
  | bvsmod                      :: :: Bvsmod            
  | bvult                       :: :: Bvult                     
  | bvslt                       :: :: Bvslt                     
  | bvule                       :: :: Bvule                     
  | bvsle                       :: :: Bvsle                     
  | bvuge                       :: :: Bvuge                     
  | bvsge                       :: :: Bvsge                     
  | bvugt                       :: :: Bvugt                     
  | bvsgt                       :: :: Bvsgt                     
  | bvshl                       :: :: Bvshl 
  | bvlshr                      :: :: Bvlshr
  | bvashr                      :: :: Bvashr
  | concat                      :: :: Concat

exp :: '' ::= {{ aux _ l }}
  | var                         :: :: Var 
  | bv                          :: :: Bits 
  | bool                        :: :: Bool 
  | ( unop exp )                :: :: Unop
  | ( binop exp1 exp2 )         :: :: Binop
  | (= exp1 exp2 )              :: :: Eq
  | ( ite exp1 exp2 exp3 )      :: :: Ite

def :: '' ::=  {{ aux _ l }}
  | ( declare-const var ty )    :: :: DeclareConst
  | ( define-const var exp )    :: :: DefineConst
  | ( assert exp )              :: :: Assert



%%% events %%%

accessor :: '' ::=
  | (_ field name )                                                                             :: :: Field  

accessor_list :: '' ::=
  | nil                                                                                         :: :: Nil
  | ( accessor1 .. accessork )                                                                  :: :: Cons

event :: '' ::=  {{ aux _ l }}
  |  def                                                                                        :: :: Smt
  |  ( branch  u32  str )
                :: :: Branch
  |  ( read-reg name accessor_list valu )                                                       :: :: ReadReg
  |  ( write-reg name accessor_list valu )                                                      :: :: WriteReg
%  |  ( read-mem  { valuue: u32 , read_kind: valu, address: valu', bytes: u32' }                :: :: ReadMem
%  |  WriteMem { valuue: u32 , write_kind: valu, address: valu', data: valu'', bytes: u32' }    :: :: WriteMem

% not sure how ReadMem and WriteMem will be rendered



%%% top-level %%%

trc :: '' ::= {{ aux _ l }}
 | ( trace event1 .. eventj )                                                                   :: :: Trace


term :: '' ::= {{ menhir-start }}
% | def                                                                                         :: :: Def
% | event                                                                                       :: :: Event
 | trc1 ... trck                                                                                :: :: Traces
% including def and event here for now just for handier testing



