(* Generated by Ott 0.33 from: isla_lang.ott 
   To keep it consistent with isla_lang.ott, update this file manually after a new build. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import Ott.ott_list_core.


(*REAL_START*)
From Coq Require Export String.
From stdpp.unstable Require Export bitvector.

Definition var_name : Set := Z.
Bind Scope Z_scope with var_name.
Definition eq_var_name (v w : var_name) : bool := Z.eqb v w.

Definition sail_name : Set := string.

Inductive annot : Type :=
| Mk_annot : annot.


Inductive accessor : Set := 
 | Field (name5:sail_name).

Inductive bvarith : Set := 
 | Bvnand : bvarith
 | Bvnor : bvarith
 | Bvxnor : bvarith
 | Bvsub : bvarith
 | Bvudiv : bvarith
 | Bvudivi : bvarith
 | Bvsdiv : bvarith
 | Bvsdivi : bvarith
 | Bvurem : bvarith
 | Bvsrem : bvarith
 | Bvsmod : bvarith
 | Bvshl : bvarith
 | Bvlshr : bvarith
 | Bvashr : bvarith.

Inductive bvcomp : Set := 
 | Bvult : bvcomp
 | Bvslt : bvcomp
 | Bvule : bvcomp
 | Bvsle : bvcomp
 | Bvuge : bvcomp
 | Bvsge : bvcomp
 | Bvugt : bvcomp
 | Bvsgt : bvcomp.

Inductive bvmanyarith : Set := 
 | Bvand : bvmanyarith
 | Bvor : bvmanyarith
 | Bvxor : bvmanyarith
 | Bvadd : bvmanyarith
 | Bvmul : bvmanyarith.

Definition accessor_list : Set := list accessor.

Inductive unop : Set := 
 | Not : unop
 | Bvnot : unop
 | Bvredand : unop
 | Bvredor : unop
 | Bvneg : unop
 | Extract (nat5:N) (nat':N)
 | ZeroExtend (nat5:N)
 | SignExtend (nat5:N).

Inductive binop : Set := 
 | Eq : binop
 | Bvarith (bvarith5:bvarith)
 | Bvcomp (bvcomp5:bvcomp).

Inductive manyop : Set := 
 | And : manyop
 | Or : manyop
 | Bvmanyarith (bvmanyarith5:bvmanyarith)
 | Concat : manyop.

Inductive base_val : Set := 
 | Val_Symbolic (vvar5:var_name)
 | Val_Bool (bool5:bool)
 | Val_Bits (bv5:bvn)
 | Val_Enum (name5:sail_name).

Inductive assume_val : Set := 
 | AVal_Var (name5:sail_name) (accessor_list5:accessor_list)
 | AVal_Bool (bool5:bool)
 | AVal_Bits (bv5:bvn)
 | AVal_Enum (name5:sail_name).

Inductive ty : Set := 
 | Ty_Bool : ty
 | Ty_BitVec (nat5:N)
 | Ty_Enum (name5:sail_name)
 | Ty_Array (ty1:ty) (ty2:ty).

Inductive exp : Set := 
 | Val (base_val5:base_val) (annot5:annot)
 | Unop (unop5:unop) (exp5:exp) (annot5:annot)
 | Binop (binop5:binop) (exp1:exp) (exp2:exp) (annot5:annot)
 | Manyop (manyop5:manyop) (_:list exp) (annot5:annot)
 | Ite (exp1:exp) (exp2:exp) (exp3:exp) (annot5:annot).

Inductive valu : Set := 
 | RegVal_Base (base_val5:base_val)
 | RegVal_I (bvi5:Z) (int5:Z)
 | RegVal_String (str5:string)
 | RegVal_Unit : valu
 | RegVal_Vector (_:list valu)
 | RegVal_List (_:list valu)
 | RegVal_Struct (_:list (sail_name * valu))
 | RegVal_Constructor (name5:sail_name) (valu5:valu)
 | RegVal_Poison : valu.

Inductive a_exp : Set := 
 | AExp_Val (assume_val5:assume_val) (annot5:annot)
 | AExp_Unop (unop5:unop) (a_exp5:a_exp) (annot5:annot)
 | AExp_Binop (binop5:binop) (a_exp1:a_exp) (a_exp2:a_exp) (annot5:annot)
 | AExp_Manyop (manyop5:manyop) (_:list a_exp) (annot5:annot)
 | AExp_Ite (a_exp1:a_exp) (a_exp2:a_exp) (a_exp3:a_exp) (annot5:annot).

Inductive smt : Set := 
 | DeclareConst (vvar5:var_name) (ty5:ty)
 | DefineConst (vvar5:var_name) (exp5:exp)
 | Assert (exp5:exp)
 | DefineEnum (name_5:sail_name) (int5:Z) (_:list sail_name).

Definition arg_list : Set := list valu.

Definition tag_value : Set := option valu.

Inductive segment : Set := 
 | Segment (name5:sail_name) (nat5:N) (vvar5:var_name) (*r The segment's original name, its size in bits, the SMT variable *).

Inductive event : Set := 
 | Smt (smt5:smt) (annot5:annot)
 | Branch (int5:Z) (str5:string) (annot5:annot) (*r Sail trace fork *)
 | ReadReg (name5:sail_name) (accessor_list5:accessor_list) (valu5:valu) (annot5:annot) (*r read value `valu` from register `name` *)
 | WriteReg (name5:sail_name) (accessor_list5:accessor_list) (valu5:valu) (annot5:annot) (*r write value `valu` to register `name` *)
 | ReadMem (valu5:valu) (rkind:valu) (addr:valu) (num_bytes:N) (tag_value5:tag_value) (annot5:annot) (*r read value `valu` from memory address `addr`, with read kind `rkind`, byte width `byte\_width`, and `tag\_value` is the optional capability tag *)
 | WriteMem (valu5:valu) (wkind:valu) (addr:valu) (data:valu) (num_bytes:N) (tag_value5:tag_value) (annot5:annot) (*r write value `valu` to memory address `addr`, with write kind `wkind`, byte width `num\_bytes`, `tag\_value` is the optional capability tag, and success flag `vvar` *)
 | BranchAddress (addr:valu) (annot5:annot) (*r announce branch address `addr`, to induce ctrl dependency in the concurrency model *)
 | Barrier (bkind:valu) (annot5:annot) (*r memory barrier of kind `bkind` *)
 | CacheOp (ckind:valu) (addr:valu) (annot5:annot) (*r cache maintenance effect of kind `ckind`, at address `addr`, for data-cache clean etc. *)
 | MarkReg (name5:sail_name) (str5:string) (annot5:annot) (*r instrumentation to tell concurrency model to ignore certain dependencies (TODO: support marking multiple registers). Currently the str is ignore-edge or ignore-write *)
 | Cycle (annot5:annot) (*r instruction boundary *)
 | Instr (opcode:valu) (annot5:annot) (*r records the instruction `opcode` that was fetched *)
 | Sleeping (vvar5:var_name) (annot5:annot) (*r Arm sleeping predicate *)
 | WakeRequest (annot5:annot) (*r Arm wake request *)
 | SleepRequest (annot5:annot) (*r Arm sleep request *)
 | Call (name5:sail_name) (annot5:annot) (*r Calls an abstract function *)
 | Return (name5:sail_name) (annot5:annot) (*r Returns from an abstract function *)
 | AssumeReg (name5:sail_name) (accessor_list5:accessor_list) (valu5:valu) (annot5:annot) (*r Notes a register assumption that Isla has been configured to use *)
 | Assume (a_exp5:a_exp) (annot5:annot) (*r Notes a constraint that Isla has been configured to assume *)
 | FunAssume (name5:sail_name) (valu5:valu) (arg_list5:arg_list) (annot5:annot) (*r Notes that the user has supplied a precondition for a particular function *)
 | UseFunAssume (name5:sail_name) (valu5:valu) (arg_list5:arg_list) (annot5:annot) (*r A use of a pre-declared function assumption *)
 | AbstractCall (name5:sail_name) (valu5:valu) (arg_list5:arg_list) (annot5:annot) (*r A function call that Isla has abstract *)
 | AbstractPrimop (name5:sail_name) (valu5:valu) (arg_list5:arg_list) (annot5:annot) (*r A primitive operation that Isla treats as abstract *).

Inductive instruction_segments : Set := 
 | Segments (_:list segment).

Definition trc : Set := list event.

Inductive maybe_fork : Set := 
 | Cases (str5:string) (_:list tree_trc)
 | End : maybe_fork
with tree_trc : Set := 
 | TreeTrace (_:list event) (maybe_fork5:maybe_fork).

Definition trcs : Set := list (list event).

Inductive whole_tree : Set := 
 | BareTree (tree_trc5:tree_trc)
 | TreeWithSegments (instruction_segments5:instruction_segments) (tree_trc5:tree_trc).
(** induction principles *)
Section exp_rect.

Variables
  (P_list_exp : list exp -> Prop)
  (P_exp : exp -> Prop).

Hypothesis
  (H_Val : forall (base_val5:base_val), forall (annot5:annot), P_exp (Val base_val5 annot5))
  (H_Unop : forall (unop5:unop), forall (exp5:exp), P_exp exp5 -> forall (annot5:annot), P_exp (Unop unop5 exp5 annot5))
  (H_Binop : forall (binop5:binop), forall (exp1:exp), P_exp exp1 -> forall (exp2:exp), P_exp exp2 -> forall (annot5:annot), P_exp (Binop binop5 exp1 exp2 annot5))
  (H_Manyop : forall (exp_list:list exp), P_list_exp exp_list -> forall (manyop5:manyop), forall (annot5:annot), P_exp (Manyop manyop5 exp_list annot5))
  (H_Ite : forall (exp1:exp), P_exp exp1 -> forall (exp2:exp), P_exp exp2 -> forall (exp3:exp), P_exp exp3 -> forall (annot5:annot), P_exp (Ite exp1 exp2 exp3 annot5))
  (H_list_exp_nil : P_list_exp nil)
  (H_list_exp_cons : forall (exp0:exp), P_exp exp0 -> forall (exp_l:list exp), P_list_exp exp_l -> P_list_exp (cons exp0 exp_l)).

Fixpoint exp_ott_ind (n:exp) : P_exp n :=
  match n as x return P_exp x with
  | (Val base_val5 annot5) => H_Val base_val5 annot5
  | (Unop unop5 exp5 annot5) => H_Unop unop5 exp5 (exp_ott_ind exp5) annot5
  | (Binop binop5 exp1 exp2 annot5) => H_Binop binop5 exp1 (exp_ott_ind exp1) exp2 (exp_ott_ind exp2) annot5
  | (Manyop manyop5 exp_list annot5) => H_Manyop exp_list (((fix exp_list_ott_ind (exp_l:list exp) : P_list_exp exp_l := match exp_l as x return P_list_exp x with nil => H_list_exp_nil | cons exp1 xl => H_list_exp_cons exp1(exp_ott_ind exp1)xl (exp_list_ott_ind xl) end)) exp_list) manyop5 annot5
  | (Ite exp1 exp2 exp3 annot5) => H_Ite exp1 (exp_ott_ind exp1) exp2 (exp_ott_ind exp2) exp3 (exp_ott_ind exp3) annot5
end.

End exp_rect.


Section a_exp_rect.

Variables
  (P_list_a_exp : list a_exp -> Prop)
  (P_a_exp : a_exp -> Prop).

Hypothesis
  (H_AExp_Val : forall (assume_val5:assume_val), forall (annot5:annot), P_a_exp (AExp_Val assume_val5 annot5))
  (H_AExp_Unop : forall (unop5:unop), forall (a_exp5:a_exp), P_a_exp a_exp5 -> forall (annot5:annot), P_a_exp (AExp_Unop unop5 a_exp5 annot5))
  (H_AExp_Binop : forall (binop5:binop), forall (a_exp1:a_exp), P_a_exp a_exp1 -> forall (a_exp2:a_exp), P_a_exp a_exp2 -> forall (annot5:annot), P_a_exp (AExp_Binop binop5 a_exp1 a_exp2 annot5))
  (H_AExp_Manyop : forall (a_exp_list:list a_exp), P_list_a_exp a_exp_list -> forall (manyop5:manyop), forall (annot5:annot), P_a_exp (AExp_Manyop manyop5 a_exp_list annot5))
  (H_AExp_Ite : forall (a_exp1:a_exp), P_a_exp a_exp1 -> forall (a_exp2:a_exp), P_a_exp a_exp2 -> forall (a_exp3:a_exp), P_a_exp a_exp3 -> forall (annot5:annot), P_a_exp (AExp_Ite a_exp1 a_exp2 a_exp3 annot5))
  (H_list_a_exp_nil : P_list_a_exp nil)
  (H_list_a_exp_cons : forall (a_exp0:a_exp), P_a_exp a_exp0 -> forall (a_exp_l:list a_exp), P_list_a_exp a_exp_l -> P_list_a_exp (cons a_exp0 a_exp_l)).

Fixpoint a_exp_ott_ind (n:a_exp) : P_a_exp n :=
  match n as x return P_a_exp x with
  | (AExp_Val assume_val5 annot5) => H_AExp_Val assume_val5 annot5
  | (AExp_Unop unop5 a_exp5 annot5) => H_AExp_Unop unop5 a_exp5 (a_exp_ott_ind a_exp5) annot5
  | (AExp_Binop binop5 a_exp1 a_exp2 annot5) => H_AExp_Binop binop5 a_exp1 (a_exp_ott_ind a_exp1) a_exp2 (a_exp_ott_ind a_exp2) annot5
  | (AExp_Manyop manyop5 a_exp_list annot5) => H_AExp_Manyop a_exp_list (((fix a_exp_list_ott_ind (a_exp_l:list a_exp) : P_list_a_exp a_exp_l := match a_exp_l as x return P_list_a_exp x with nil => H_list_a_exp_nil | cons a_exp1 xl => H_list_a_exp_cons a_exp1(a_exp_ott_ind a_exp1)xl (a_exp_list_ott_ind xl) end)) a_exp_list) manyop5 annot5
  | (AExp_Ite a_exp1 a_exp2 a_exp3 annot5) => H_AExp_Ite a_exp1 (a_exp_ott_ind a_exp1) a_exp2 (a_exp_ott_ind a_exp2) a_exp3 (a_exp_ott_ind a_exp3) annot5
end.

End a_exp_rect.


Section tree_trc_maybe_fork_rect.

Variables
  (P_tree_trc : tree_trc -> Prop)
  (P_maybe_fork : maybe_fork -> Prop)
  (P_list_tree_trc : list tree_trc -> Prop).

Hypothesis
  (H_TreeTrace : forall (event_list:list event), forall (maybe_fork5:maybe_fork), P_maybe_fork maybe_fork5 -> P_tree_trc (TreeTrace event_list maybe_fork5))
  (H_Cases : forall (tree_trc_list:list tree_trc), P_list_tree_trc tree_trc_list -> forall (str5:string), P_maybe_fork (Cases str5 tree_trc_list))
  (H_End : P_maybe_fork End)
  (H_list_tree_trc_nil : P_list_tree_trc nil)
  (H_list_tree_trc_cons : forall (tree_trc0:tree_trc), P_tree_trc tree_trc0 -> forall (tree_trc_l:list tree_trc), P_list_tree_trc tree_trc_l -> P_list_tree_trc (cons tree_trc0 tree_trc_l)).

Fixpoint maybe_fork_ott_ind (n:maybe_fork) : P_maybe_fork n :=
  match n as x return P_maybe_fork x with
  | (Cases str5 tree_trc_list) => H_Cases tree_trc_list (((fix tree_trc_list_ott_ind (tree_trc_l:list tree_trc) : P_list_tree_trc tree_trc_l := match tree_trc_l as x return P_list_tree_trc x with nil => H_list_tree_trc_nil | cons tree_trc1 xl => H_list_tree_trc_cons tree_trc1(tree_trc_ott_ind tree_trc1)xl (tree_trc_list_ott_ind xl) end)) tree_trc_list) str5
  | End => H_End 
end
with tree_trc_ott_ind (n:tree_trc) : P_tree_trc n :=
  match n as x return P_tree_trc x with
  | (TreeTrace event_list maybe_fork5) => H_TreeTrace event_list maybe_fork5 (maybe_fork_ott_ind maybe_fork5)
end.

End tree_trc_maybe_fork_rect.

(** substitutions *)
Definition subst_val_base_val (base_val5:base_val) (vvar_6:var_name) (base_val_6:base_val) : base_val :=
  match base_val_6 with
  | (Val_Symbolic vvar5) => (if eq_var_name vvar5 vvar_6 then base_val5 else (Val_Symbolic vvar5))
  | (Val_Bool bool5) => Val_Bool bool5
  | (Val_Bits bv5) => Val_Bits bv5
  | (Val_Enum name5) => Val_Enum name5
end.

Fixpoint subst_val_exp (base_val_6:base_val) (vvar5:var_name) (exp_6:exp) {struct exp_6} : exp :=
  match exp_6 with
  | (Val base_val5 annot5) => Val (subst_val_base_val base_val_6 vvar5 base_val5) annot5
  | (Unop unop5 exp5 annot5) => Unop unop5 (subst_val_exp base_val_6 vvar5 exp5) annot5
  | (Binop binop5 exp1 exp2 annot5) => Binop binop5 (subst_val_exp base_val_6 vvar5 exp1) (subst_val_exp base_val_6 vvar5 exp2) annot5
  | (Manyop manyop5 exp_list annot5) => Manyop manyop5 (map (fun (exp_:exp) => (subst_val_exp base_val_6 vvar5 exp_)) exp_list) annot5
  | (Ite exp1 exp2 exp3 annot5) => Ite (subst_val_exp base_val_6 vvar5 exp1) (subst_val_exp base_val_6 vvar5 exp2) (subst_val_exp base_val_6 vvar5 exp3) annot5
end.

Definition subst_val_smt (base_val5:base_val) (vvar_6:var_name) (smt5:smt) : smt :=
  match smt5 with
  | (DeclareConst vvar5 ty5) => DeclareConst vvar5 ty5
  | (DefineConst vvar5 exp5) => DefineConst vvar5 (subst_val_exp base_val5 vvar_6 exp5)
  | (Assert exp5) => Assert (subst_val_exp base_val5 vvar_6 exp5)
  | (DefineEnum name_5 int5 name_list) => DefineEnum name_5 int5 name_list
end.

Fixpoint subst_val_valu (base_val_6:base_val) (vvar5:var_name) (addr5:valu) {struct addr5} : valu :=
  match addr5 with
  | (RegVal_Base base_val5) => RegVal_Base (subst_val_base_val base_val_6 vvar5 base_val5)
  | (RegVal_I bvi5 int5) => RegVal_I bvi5 int5
  | (RegVal_String str5) => RegVal_String str5
  | RegVal_Unit => RegVal_Unit 
  | (RegVal_Vector valu_list) => RegVal_Vector (map (fun (valu_:valu) => (subst_val_valu base_val_6 vvar5 valu_)) valu_list)
  | (RegVal_List valu_list) => RegVal_List (map (fun (valu_:valu) => (subst_val_valu base_val_6 vvar5 valu_)) valu_list)
  | (RegVal_Struct selem_list) => RegVal_Struct (map (fun '(name,valu) => (name, subst_val_valu base_val_6 vvar5 valu)) selem_list)
  | (RegVal_Constructor name5 valu5) => RegVal_Constructor name5 (subst_val_valu base_val_6 vvar5 valu5)
  | RegVal_Poison => RegVal_Poison 
end.

Definition subst_val_event (base_val5:base_val) (vvar_6:var_name) (event5:event) : event :=
  match event5 with
  | (Smt smt5 annot5) => Smt (subst_val_smt base_val5 vvar_6 smt5) annot5
  | (Branch int5 str5 annot5) => Branch int5 str5 annot5
  | (ReadReg name5 accessor_list5 valu5 annot5) => ReadReg name5 accessor_list5 (subst_val_valu base_val5 vvar_6 valu5) annot5
  | (WriteReg name5 accessor_list5 valu5 annot5) => WriteReg name5 accessor_list5 (subst_val_valu base_val5 vvar_6 valu5) annot5
  | (ReadMem valu5 rkind addr num_bytes tag_value5 annot5) => ReadMem (subst_val_valu base_val5 vvar_6 valu5) (subst_val_valu base_val5 vvar_6 rkind) (subst_val_valu base_val5 vvar_6 addr) num_bytes tag_value5 annot5
  | (WriteMem valu5 wkind addr data num_bytes tag_value5 annot5) => WriteMem (subst_val_valu base_val5 vvar_6 valu5) (subst_val_valu base_val5 vvar_6 wkind) (subst_val_valu base_val5 vvar_6 addr) (subst_val_valu base_val5 vvar_6 data) num_bytes tag_value5 annot5
  | (BranchAddress addr annot5) => BranchAddress (subst_val_valu base_val5 vvar_6 addr) annot5
  | (Barrier bkind annot5) => Barrier (subst_val_valu base_val5 vvar_6 bkind) annot5
  | (CacheOp ckind addr annot5) => CacheOp (subst_val_valu base_val5 vvar_6 ckind) (subst_val_valu base_val5 vvar_6 addr) annot5
  | (MarkReg name5 str5 annot5) => MarkReg name5 str5 annot5
  | (Cycle annot5) => Cycle annot5
  | (Instr opcode annot5) => Instr (subst_val_valu base_val5 vvar_6 opcode) annot5
  | (Sleeping vvar5 annot5) => Sleeping vvar5 annot5
  | (WakeRequest annot5) => WakeRequest annot5
  | (SleepRequest annot5) => SleepRequest annot5
  | (Call name5 annot5) => Call name5 annot5
  | (Return name5 annot5) => Return name5 annot5
  | (AssumeReg name5 accessor_list5 valu5 annot5) => AssumeReg name5 accessor_list5 (subst_val_valu base_val5 vvar_6 valu5) annot5
  | (Assume a_exp5 annot5) => Assume a_exp5 annot5
  | (FunAssume name5 valu5 arg_list5 annot5) => FunAssume name5 (subst_val_valu base_val5 vvar_6 valu5) arg_list5 annot5
  | (UseFunAssume name5 valu5 arg_list5 annot5) => UseFunAssume name5 (subst_val_valu base_val5 vvar_6 valu5) arg_list5 annot5
  | (AbstractCall name5 valu5 arg_list5 annot5) => AbstractCall name5 (subst_val_valu base_val5 vvar_6 valu5) arg_list5 annot5
  | (AbstractPrimop name5 valu5 arg_list5 annot5) => AbstractPrimop name5 (subst_val_valu base_val5 vvar_6 valu5) arg_list5 annot5
end.

Fixpoint subst_val_tree_trc (base_val5:base_val) (vvar5:var_name) (tree_trc5:tree_trc) {struct tree_trc5} : tree_trc :=
  match tree_trc5 with
  | (TreeTrace event_list maybe_fork5) => TreeTrace (map (fun (event_:event) => (subst_val_event base_val5 vvar5 event_)) event_list) (subst_val_maybe_fork base_val5 vvar5 maybe_fork5)
end
with subst_val_maybe_fork (base_val5:base_val) (vvar5:var_name) (maybe_fork5:maybe_fork) {struct maybe_fork5} : maybe_fork :=
  match maybe_fork5 with
  | (Cases str5 tree_trc_list) => Cases str5 (map (fun (tree_trc_:tree_trc) => (subst_val_tree_trc base_val5 vvar5 tree_trc_)) tree_trc_list)
  | End => End 
end.

Definition subst_val_whole_tree (base_val5:base_val) (vvar5:var_name) (whole_tree5:whole_tree) : whole_tree :=
  match whole_tree5 with
  | (BareTree tree_trc5) => BareTree (subst_val_tree_trc base_val5 vvar5 tree_trc5)
  | (TreeWithSegments instruction_segments5 tree_trc5) => TreeWithSegments instruction_segments5 (subst_val_tree_trc base_val5 vvar5 tree_trc5)
end.


(* TODO move this to traces.v when nobody depends on this file as-is *)

Notation RVal_Symbolic b := (RegVal_Base (Val_Symbolic b)).
Notation RVal_Bool b := (RegVal_Base (Val_Bool b)).
Notation RVal_Bits b := (RegVal_Base (Val_Bits b)).
Notation RVal_Enum b := (RegVal_Base (Val_Enum b)).

Definition base_val_to_exp (v : base_val) : exp := Val v Mk_annot.
Coercion base_val_to_exp : base_val >-> exp.




